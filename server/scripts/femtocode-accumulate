#!/usr/bin/env python

# Copyright 2016 DIANA-HEP
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import textwrap
try:
    from urllib2 import urlparse
except ImportError:
    from urllib.parse import urlparse

from femtocode.util import *
from femtocode.server.cache import RolloverCache
from femtocode.server.accumulate import Foreman
from femtocode.server.accumulate import ForemanServer

class Formatter(argparse.HelpFormatter):
    def _fill_text(self, text, width, indent):
        return "\n".join(textwrap.fill(x, width) for x in text.splitlines())

if __name__ == "__main__":
    argumentParser = argparse.ArgumentParser(description="""A femtocode-accumulate process aggregates subtallies from femtocode-compute processes and responds to requests from femtocode-dispatch with the current partial result (if still running) or the final result (if remembered).

A femtocode-accumulate process has the following responsibilities:

   - "Owns" a collection of queries, assigns parts of their work to femtocode-compute processes, and reassigns them if femtocode-compute processes disappear.
   - Runs code (compiled by femtocode-dispatch) to combine subtallies into the final result.
   - Maintains a disk-based cache of old final results.

Femtocode-accumulate processes are STATEFUL: they keep a query and its executor in memory while the work is in progress and keep a disk cache of old results. Restarting a femtocode-accumulate process effectively cancels its ongoing queries, but a new process can reuse the old one's disk-based cache. Losing a disk simply forces the old queries to be recomputed.

Communication with femtocode-dispatch and femtocode-compute is ZeroMQ.

We assume that femtocode-dispatch, femtocode-accumulate, and femtocode-compute run on the same processor architecture, accepting the same bytecode.

A femtocode-accumulate process must be given a SUPERSET of femtocode-compute server:ports. It can recover from missing femtocode-computes, but it cannot discover new ones.""", formatter_class=Formatter)

    argumentParser.add_argument("self", help="""fully qualified ZeroMQ URL (e.g. tcp://server:port) pointing to this process, used as a return address for work sent to femtocode-compute""")
    argumentParser.add_argument("computes", nargs="+", help="""ZeroMQ URLs for at least one compute process""")
    argumentParser.add_argument("--cache-dir", metavar="DIR", required=True, help="""directory for caching old results (REQUIRED)""")
    argumentParser.add_argument("--cache-margin", metavar="BYTES", required=True, help="""number of UNUSED bytes on cache-dir's partition before deleting old rollover subdirectories (REQUIRED); trailing 'k', 'm', 'g' will reinterpret as kilobytes, megabytes, or gigabytes""")
    argumentParser.add_argument("--cache-roll", metavar="SECS", type=int, default=60*60, help="""number of seconds represented by one rollover subdirectory (default 3600; 1 hour)""")
    argumentParser.add_argument("--cache-gc", metavar="SECS", type=int, default=60, help="""number of seconds pause between invocations of the garbage collector (default 60; 1 minute)""")
    argumentParser.add_argument("--cache-idchars", metavar="CHRS", default=8, type=int, help="""number of characters of the query id to use per nested directory name (default 8; 16-character query id yields a two-level directory hierarchy)""")
    argumentParser.add_argument("--timeout", metavar="SECS", default=0.5, type=float, help="""number of seconds to wait before calling a compute process "dead" (default: 0.5 sec)""")

    args = argumentParser.parse_args()

    port = urlparse.urlparse(args.self).port

    margin = args.cache_margin.strip()
    if margin.lower().endswith("k"):
        margin = roundup(float(margin[:-1]) * 1024)
    elif margin.lower().endswith("m"):
        margin = roundup(float(margin[:-1]) * 1024**2)
    elif margin.lower().endswith("g"):
        margin = roundup(float(margin[:-1]) * 1024**3)
    else:
        margin = roundup(float(margin))

    rolloverCache = RolloverCache(args.cache_dir, margin, args.cache_roll, args.cache_gc, args.cache_idchars)

    foreman = Foreman(args.self, args.computes, rolloverCache, args.timeout)

    server = ForemanServer(foreman, "tcp://*:{0}".format(port))
    server.run()
