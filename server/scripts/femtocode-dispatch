#!/usr/bin/env python

# Copyright 2016 DIANA-HEP
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os.path
import textwrap
try:
    from urllib2 import urlparse
except ImportError:
    from urllib.parse import urlparse

from femtocode.dataset import MetadataFromJson
from femtocode.server.mongodb import MetadataFromMongoDB
from femtocode.server.dispatch import DispatchAPIServer
from femtocode.server.dispatch import MetadataAPIServer
from femtocode.server.accumulate import ForemanClient

class Formatter(argparse.HelpFormatter):
    def _fill_text(self, text, width, indent):
        return "\n".join(textwrap.fill(x, width) for x in text.splitlines())

if __name__ == "__main__":
    argumentParser = argparse.ArgumentParser(description="""A femtocode-dispatch process acts as a front-end to clients, hiding the complexity of the server architecture from users.

A femtocode-dispatch process has the following responsibilities:

   - Redirects user requests for metadata to the appropriate source.
   - Accepts queries as Femtocode-compiled lists of statements.
   - Checks all femtocode-accumulate processes to see if one "owns" the query.
      - If so, forwards the femtocode-accumulate's response back to the user.
      - If not, byte-compiles the query and assigns it to the femtocode-accumulate with the least load.

Femtocode-dispatch processes are STATELESS; they may be restarted with impunity and put behind a naive load-balancer.

The user-facing server is HTTP; communication with femtocode-accumulate is ZeroMQ. Metadata may be file-based or a database.

We assume that femtocode-dispatch, femtocode-accumulate, and femtocode-compute run on the same processor architecture, accepting the same bytecode.

A femtocode-dispatch process must be given a SUPERSET of femtocode-accumulate server:ports. It can recover from missing femtocode-accumulates, but it cannot discover new ones.""", formatter_class=Formatter)

    argumentParser.add_argument("metadata", help="""directory path for file-based metadata, URL for remote (e.g. mongodb://site:port/;db;collection)""")
    argumentParser.add_argument("accumulates", nargs="+", help="""ZeroMQ URLs (e.g. tcp://server:port) for at least one accumulate process""")
    argumentParser.add_argument("--bind", metavar="ADDR", default="", help="""address pattern from which to accept incoming HTTP requests (default: accept requests from anywhere)""")
    argumentParser.add_argument("--port", metavar="PORT", default=80, type=int, help="""port on which to accept incoming HTTP requests (default: 80)""")
    argumentParser.add_argument("--timeout", metavar="SECS", default=0.5, type=float, help="""number of seconds to wait before calling an accumulate process "dead" (default: 0.5 sec)""")

    args = argumentParser.parse_args()

    metadataurl = urlparse.urlparse(args.metadata)

    if metadataurl.scheme == "file" or (metadataurl.scheme == "" and metadataurl.netloc == ""):
        if metadataurl.netloc is not "":
            path = os.path.join(os.sep, metadataurl.netloc, *metadataurl.path.split("/"))

        elif metadataurl.path.startswith("/"):
            path = os.path.join(os.sep, *metadataurl.path.split("/"))

        else:
            path = os.path.join(*metadataurl.path.split("/"))

        metadb = MetadataAPIServer(MetadataFromJson(path), None, None)

    elif metadataurl.scheme == "mongodb":
        url = urlparse.urlunparse(urlparse.ParseResult(metadataurl.scheme, metadataurl.netloc, metadataurl.path, "", "", ""))
        database = "test"
        collection = "datasets"
        for i, param in enumerate(metadataurl.params.split(";")):
            if i == 0:
                database = param
            elif i == 1:
                collection = param

        metadb = MetadataAPIServer(MetadataFromMongoDB(url, database, collection, args.timeout), None, None)

    else:
        raise NotImplementedError("Only MetadataFromJson and MetadataFromMongoDB implemented so far.")

    accumulates = []
    for accumulate in args.accumulates:
        accumulates.append(ForemanClient(accumulate, args.timeout))

    server = DispatchAPIServer(metadb, accumulates, args.bind, args.port, args.timeout)
    server.start()
